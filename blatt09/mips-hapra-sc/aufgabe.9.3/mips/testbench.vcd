$date
  Tue Jan 18 17:44:02 2022
$end
$version
  GHDL v0
$end
$timescale
  1 fs
$end
$var reg 1 ! clk $end
$var reg 1 " finished $end
$var reg 32 # pc[31:0] $end
$var reg 32 $ readdata[31:0] $end
$var reg 32 % aluout[31:0] $end
$var reg 32 & writedata[31:0] $end
$var reg 1 ' memwrite $end
$var reg 1 ( reset $end
$var reg 32 ) instr[31:0] $end
$scope module mips1 $end
$var reg 1 * clk $end
$var reg 1 + reset $end
$var reg 32 , pc[31:0] $end
$var reg 32 - instr[31:0] $end
$var reg 32 . readdata[31:0] $end
$var reg 32 / aluout[31:0] $end
$var reg 32 0 writedata[31:0] $end
$var reg 1 1 memwrite $end
$var reg 1 2 memtoreg $end
$var reg 1 3 alusrc $end
$var reg 1 4 regdst $end
$var reg 1 5 regwrite $end
$var reg 1 6 jump $end
$var reg 1 7 pcsrc $end
$var reg 1 8 zero $end
$var reg 3 9 alucontrol[2:0] $end
$scope module mips_control $end
$var reg 6 : op[5:0] $end
$var reg 6 ; funct[5:0] $end
$var reg 1 < zero $end
$var reg 1 = memtoreg $end
$var reg 1 > memwrite $end
$var reg 1 ? pcsrc $end
$var reg 1 @ alusrc $end
$var reg 1 A regdst $end
$var reg 1 B regwrite $end
$var reg 1 C jump $end
$var reg 3 D alucontrol[2:0] $end
$var reg 2 E aluop[1:0] $end
$var reg 1 F branch $end
$scope module md $end
$var reg 6 G op[5:0] $end
$var reg 1 H memtoreg $end
$var reg 1 I memwrite $end
$var reg 1 J branch $end
$var reg 1 K alusrc $end
$var reg 1 L regdst $end
$var reg 1 M regwrite $end
$var reg 1 N jump $end
$var reg 2 O aluop[1:0] $end
$var reg 9 P controls[8:0] $end
$upscope $end
$scope module ad $end
$var reg 6 Q funct[5:0] $end
$var reg 2 R aluop[1:0] $end
$var reg 3 S alucontrol[2:0] $end
$upscope $end
$upscope $end
$scope module mips_datapath $end
$var reg 1 T clk $end
$var reg 1 U reset $end
$var reg 1 V memtoreg $end
$var reg 1 W pcsrc $end
$var reg 1 X alusrc $end
$var reg 1 Y regdst $end
$var reg 1 Z regwrite $end
$var reg 1 [ jump $end
$var reg 3 \ alucontrol[2:0] $end
$var reg 32 ] readdata[31:0] $end
$var reg 32 ^ instr[31:0] $end
$var reg 1 _ zero $end
$var reg 32 ` pc[31:0] $end
$var reg 32 a aluout[31:0] $end
$var reg 32 b writedata[31:0] $end
$var reg 5 c writereg[4:0] $end
$var reg 32 d pcjump[31:0] $end
$var reg 32 e pcnext[31:0] $end
$var reg 32 f pcnextbr[31:0] $end
$var reg 32 g pcplus4[31:0] $end
$var reg 32 h pcbranch[31:0] $end
$var reg 32 i signimm[31:0] $end
$var reg 32 j signimmsh[31:0] $end
$var reg 32 k srca[31:0] $end
$var reg 32 l srcb[31:0] $end
$var reg 32 m result[31:0] $end
$scope module pcreg $end
$var reg 1 n clk $end
$var reg 1 o reset $end
$var reg 32 p d[31:0] $end
$var reg 32 q q[31:0] $end
$upscope $end
$scope module pcadd1 $end
$var reg 32 r a[31:0] $end
$var reg 32 s b[31:0] $end
$var reg 32 t y[31:0] $end
$upscope $end
$scope module immsh $end
$var reg 32 u a[31:0] $end
$var reg 32 v y[31:0] $end
$upscope $end
$scope module pcadd2 $end
$var reg 32 w a[31:0] $end
$var reg 32 x b[31:0] $end
$var reg 32 y y[31:0] $end
$upscope $end
$scope module pcbrmux $end
$var reg 32 z d0[31:0] $end
$var reg 32 { d1[31:0] $end
$var reg 1 | s $end
$var reg 32 } y[31:0] $end
$upscope $end
$scope module pcmux $end
$var reg 32 !" d0[31:0] $end
$var reg 32 "" d1[31:0] $end
$var reg 1 #" s $end
$var reg 32 $" y[31:0] $end
$upscope $end
$scope module rf $end
$var reg 1 %" clk $end
$var reg 1 &" we3 $end
$var reg 5 '" a1[4:0] $end
$var reg 5 (" a2[4:0] $end
$var reg 5 )" a3[4:0] $end
$var reg 32 *" wd3[31:0] $end
$var reg 32 +" rd1[31:0] $end
$var reg 32 ," rd2[31:0] $end
$comment mem is not handled $end
$upscope $end
$scope module wrmux $end
$var reg 5 -" d0[4:0] $end
$var reg 5 ." d1[4:0] $end
$var reg 1 /" s $end
$var reg 5 0" y[4:0] $end
$upscope $end
$scope module resmux $end
$var reg 32 1" d0[31:0] $end
$var reg 32 2" d1[31:0] $end
$var reg 1 3" s $end
$var reg 32 4" y[31:0] $end
$upscope $end
$scope module se $end
$var reg 16 5" a[15:0] $end
$var reg 32 6" aext[31:0] $end
$upscope $end
$scope module srcbmux $end
$var reg 32 7" d0[31:0] $end
$var reg 32 8" d1[31:0] $end
$var reg 1 9" s $end
$var reg 32 :" y[31:0] $end
$upscope $end
$scope module mainalu $end
$var reg 32 ;" a[31:0] $end
$var reg 32 <" b[31:0] $end
$var reg 3 =" alucontrol[2:0] $end
$var reg 32 >" result[31:0] $end
$var reg 1 ?" zero $end
$upscope $end
$upscope $end
$scope module mips_datamem $end
$var reg 1 @" clk $end
$var reg 1 A" we $end
$var reg 32 B" aluout[31:0] $end
$var reg 32 C" writedata[31:0] $end
$var reg 32 D" readdata[31:0] $end
$upscope $end
$scope module mips_instructmem $end
$var reg 32 E" readaddress[31:0] $end
$var reg 32 F" instruction[31:0] $end
$comment im is not handled $end
$upscope $end
$upscope $end
$enddefinitions $end
